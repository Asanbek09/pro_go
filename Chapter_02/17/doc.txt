Кто они такие?
Форматирование — это процесс объединения значений в строку. 
Сканирование — это процесс разбора строки на наличие содержащихся в ней значений.

Почему они полезны?
Форматирование строки является распространенным требованием и используется для создания строк для всего, 
от ведения журнала и отладки до представления информации пользователю. Сканирование полезно для извлечения данных из строк, 
например из HTTP-запросов или пользовательского ввода.

Как они используются?
Оба набора функций предоставляются через функции, определенные в пакете fmt.

Есть ли подводные камни или ограничения?
Шаблоны, используемые для форматирования строк, могут быть трудночитаемыми, и нет встроенной функции, 
позволяющей создать форматированную строку, к которой автоматически добавляется символ новой строки.

Есть ли альтернативы?
С помощью функций шаблона, можно создавать большие объемы текста и содержимого HTML.

Sprintf(t, ...vals)
Эта функция возвращает строку, созданную путем обработки шаблона t. 
Остальные аргументы используются в качестве значений для глаголов шаблона.

Printf(t, ...vals)
Эта функция создает строку, обрабатывая шаблон t. Остальные аргументы используются в качестве значений для глаголов шаблона.
Строка записывается на стандартный вывод.

Fprintf(writer, t, ...vals)
Эта функция создает строку, обрабатывая шаблон t.
Остальные аргументы используются в качестве значений для глаголов шаблона. Строка записывается в модуль Writer

Errorf(t, ...values)
Эта функция создает ошибку, обрабатывая шаблон t. Остальные аргументы используются в качестве значений для глаголов шаблона. 
Результатом является значение error, метод Error которого возвращает отформатированную строку.

%v
Эта команда отображает формат значения по умолчанию. Изменение глагола со знаком плюс (%+v) включает
имена полей при записи значений структуры.

%#v
Эта команда отображает значение в формате, который можно использовать для повторного создания значения в файле кода Go.

%T
Эта команда отображает тип значения Go.

%b
Эта команда отображает целочисленное значение в виде двоичной строки

%d
Эта команда отображает целочисленное значение в виде десятичной строки. 
Это формат по умолчанию для целочисленных значений, применяемый при использовании глагола %v

%o, %O
Эти команды отображают целочисленное значение в виде восьмеричной строки. Глагол %O добавляет префикс 0o.

%x, %X
Эти команды отображают целочисленное значение в виде шестнадцатеричной строки. 
Буквы от A до F отображаются в нижнем регистре с помощью глагола %x и в верхнем регистре с помощью глагола %X.

%b
Эта команда отображает значение с плавающей запятой с показателем степени и без десятичной точки

%e, %E
Эти команды отображают значение с плавающей запятой с показателем степени и десятичным разрядом. 
%e использует индикатор степени в нижнем регистре, а %E использует индикатор в верхнем регистре

%f, %F
Эти команды отображают значение с плавающей запятой с десятичным разрядом, но без экспоненты. 
Команды %f и %F производят одинаковый результат.

%g
Этот глагол адаптируется к отображаемому значению. Формат %e используется для значений с большими показателями степени, 
в противном случае используется формат %f. Это формат по умолчанию, применяемый при использовании глагола %v.

%G
Этот глагол адаптируется к отображаемому значению. Формат %E используется для значений с большими показателями степени, 
в противном случае используется формат %f.

%x, %X
Эти команды отображают значение с плавающей запятой в шестнадцатеричном представления со строчными(%x) или прописными (%X) буквами

+
Этот модификатор (знак плюс) всегда печатает знак, положительный или отрицательный, для числовых значений.

0
Этот модификатор использует нули, а не пробелы, в качестве заполнения, когда ширина превышает количество символов,
необходимое для отображения значения

-
Этот модификатор (символ вычитания) добавляет отступ справа от числа, а не слева.

%s
Этот глагол отображает строку. Это формат по умолчанию, применяемый при использовании глагола %v.

%c
Этот глагол отображает характер. Необходимо соблюдать осторожность, чтобы избежать разделения строк на отдельные байты, 
как это объясняется в тексте после таблицы.

%U
Эта команда отображает символ в формате Unicode, так что вывод начинается с U+, за которым следует шестнадцатеричный код символа.

%t
Эта команда форматирует логические значения и отображает значение true или false.

%p
Эта команда отображает шестнадцатеричное представление места хранения указателя.

Сканирование строк
Scan(...vals)
Эта функция считывает текст из стандарта и сохраняет значения, разделенные пробелами, в указанные аргументы. 
Новые строки обрабатываются как пробелы, и функция читает до тех пор, пока не получит значения для всех своих аргументов. 
Результатом является количество прочитанных значений и error, описывающая любые проблемы.

Scanln(...vals)
Эта функция работает так же, как Scan, но останавливает чтение, когда встречает символ новой строки.

Scanf(template, ...vals)
Эта функция работает так же, как Scan, но использует строку шаблона для выбора значений из получаемых входных данных.

Fscan(reader, ...vals)
Эта функция считывает значения, разделенные пробелами, из указанного средства чтения, описанного в главе 20. 
Новые строки обрабатываются как пробелы, и функция возвращает количество прочитанных значений и ошибку, описывающую любые проблемы.

Fscanln(reader, ...vals)
Эта функция работает так же, как Fscan, но останавливает чтение, когда встречает символ новой строки.

Fscanf(reader, template, ...vals)
Эта функция работает так же, как Fscan, но использует шаблон для выбора значений из получаемых входных данных.

Sscan(str, ...vals)
Эта функция просматривает указанную строку в поисках значений, разделенных пробелами, которые присваиваются остальным аргументам. 
Результатом является количество просканированных значений и ошибка, описывающая любые проблемы.

Sscanf(str, template, ...vals)
Эта функция работает так же, как Sscan, но использует шаблон для выбора значений из строки.

Sscanln(str, template, ...vals)
Эта функция работает так же, как Sscanf, но останавливает сканирование строки, как только встречается символ новой строки.