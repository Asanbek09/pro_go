------------------------------------------// Помещение массивов, срезов и карт в контекст \\------------------------------------------

Кто они такие?
Классы коллекций Go используются для группировки связанных значений. В массивах хранится фиксированное количество значений, 
в срезах хранится переменное количество значений, а в картах хранятся пары ключ-значение.

Почему они полезны?
Эти классы коллекций являются удобным способом отслеживать связанные значения данных

Как они используются?
Каждый тип коллекции можно использовать с литеральным синтаксисом или с помощью функции make.

Есть ли подводные камни или ограничения?
Необходимо соблюдать осторожность, чтобы понять, какое влияние операции, выполняемые над срезами, оказывают на базовый массив, чтобы избежать непредвиденных результатов.

Есть ли альтернативы?
Вам не обязательно использовать какой-либо из этих типов, но это упрощает большинство задач программирования

--------------------------------------------------------------------------------------------------------------------------------------

Количество элементов, указанных с литеральным синтаксисом, может быть меньше емкости массива. Любой позиции в массиве, для
которой не указано значение, будет присвоено нулевое значение для типа массива

--------------------------------------------------------------------------------------------------------------------------------------

-------------------------------------------------// СОЗДАНИЕ МНОГОМЕРНЫХ МАССИВОВ \\--------------------------------------------------

Массивы Go являются одномерными, но их можно комбинировать для создания многомерных массивов, например:
...
var coords [3][3]int
...
Этот оператор создает массив, емкость которого равна 3 и базовый тип которого является массивом int, 
также с емкостью 3, создавая массив значений int 3×3. Отдельные значения указываются с использованием двух позиций индекса, например:
...
coords[1][2] = 10
...
Синтаксис немного неудобен, особенно для массивов с большим количеством измерений, но он функционален 
и соответствует подходу Go к массивам.

--------------------------------------------------------------------------------------------------------------------------------------

-----------------------------------------// ПОЗВОЛЯЕМ КОМПИЛЯТОРУ ОПРЕДЕЛЯТЬ ДЛИНУ МАССИВА \\-----------------------------------------

При использовании литерального синтаксиса компилятор может вывести длину массива из списка элементов, например:
...
names := [...]string { "Kayak", "Lifejacket", "Paddle" } ...
Явная длина заменяется тремя точками (...), что указывает компилятору определять длину массива из литеральных значений. 
Тип переменной names по-прежнему [3]string, и единственное отличие состоит в том, что вы можете добавлять 
или удалять литеральные значения, не обновляя при этом явно указанную длину.
Я не использую эту функцию для примеров в этой книге, потому что хочу сделать используемые типы максимально понятными

--------------------------------------------------------------------------------------------------------------------------------------